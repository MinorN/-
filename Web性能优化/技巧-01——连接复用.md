# 技巧-01——连接复用

以下目前说的都是HTTP1.0/1.1

## Web性能指标

我们所说的Web性能优化，到底是优化什么？->优化用户的体验，但是这也太宽泛了，有没有比较具体的方面呢？

1. 内容出现
2. `DOM ready` 事件发生
3. 页面可以正常交互
4. `onLoad` 事件加载完
5. 动态资源加载完成

具体来说，一般以 `DOM ready` 为指标

## DNS 预解析

比如我们现在请求了两个不同域名的JS

```html
<script scr="http://xxx.com/1.js"></script>
<script scr="http://yyy.com/2.js"></script>
```

那么会先对xxx.com进行解析，拿到域名，请求1.js，然后对yyy.com进行解析，拿到域名，请求2.js

这里发现进行了两次DNS解析，并且是线性的，那么我们可以一开始先对xxx,yyy进行解析，然后再依次下载对应的js，这样就省去了一次DNS解析过程

如何实现呢？

```
// 在index.html 的 <head> 里写
<link rel="dns-prefetch" href="http://xxx.com/"></link>
// 或者 在index.html 的 响应头里
Link: <http://xxx.com>; rel=dns-prefetch
```

## 连接复用

`Connection:keep-alive`

当我们每次请求的时候都会经历以下步骤：

1. 开TCP
2. 请求
3. 响应
4. 关TCP

那么如果我们多次发送请求，那么就会有很多冗余的开启TCP、关闭TCP，这就是我们的优化点

那么我们就可以在HTTP里面添加`Connection:keep-alive`字段来保持TCP连接，那么，有个问题，我们这个连接一般会维持多久呢？

当然这个是可以进行配置的，`KeepAlive:timeout=5，max=100`

如何开启呢？HTTP1.1+默认开启

## 并发连接

我们上面了解了连接复用，本质还是串行的连接。

我们现在设想一个场景：先开启TCP，然后请求一个HTML，然后请求3个CSS。比如每个请求耗时0.5s

按照上述连接复用，这四个请求是串行的，那么这四个请求大约需要2s时间。再来思考一下，我这3个CSS为什么不能同时请求呢？然后再依次使用(解析)？所以这就有了并发连接。

第一步：开启TCP连接

第二步：请求HTML

第三步：响应HTML

第四步：开启3个新的TCP连接，同时请求3个CSS

那么，连接复用还有什么用呢？有用，因为并发连接有上限，所以连接复用这里就派上了用场

如何做到并发链接呢？拆分模块即可

## HTTP管道化

就是在上面并发连接，省去了第四步中开启3个新的TCP连接，和第一步公共用一个TCP连接。这样会导致一个问题，如果返回 200，不知道这个 200 是谁的 200，并且在最后处理的时候后面的响应不能比前面的响应早，也就是有顺序依赖